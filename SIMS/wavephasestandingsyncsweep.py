"""
Standing Wave Simulation with Frequency Sweep for Synchronous Beamforming
---------------------------------------------------------------------------
This script simulates standing waves generated by a synchronous (in-phase) beam 
excitation in the presence of a reflective boundary. Unlike the focused case, 
synchronous beamforming excites all elements with the same phase. Here, we compute,
for a range of frequencies (swept from 140 kHz to 220 kHz):
  - The Incident Field computed via delay-and-sum beamforming with zero time delay.
  - The Reflected Field simulated by flipping the incident field along the axial (z) 
    direction with a 180° phase inversion.
Averaging over the frequency band incoherently suppresses the sharp interference of a 
resonant standing wave, yielding composite fields with reduced pronounced nodes and 
antinodes.

Reference:
    Jensen, "Field II: A program for simulating ultrasound systems", 1996.
"""

import numpy as np
import matplotlib.pyplot as plt
from beamforming_utils import element_directivity, calculate_attenuation
from viz import plot_panels
import os

# Simulation parameters
low_freq = 140e3          # Lower frequency bound (Hz)
high_freq = 220e3         # Upper frequency bound (Hz)
num_freq = 5              # Number of frequencies in the sweep
freqs = np.linspace(low_freq, high_freq, num_freq)

speed_of_sound = 1480     # Speed of sound in m/s (water)
# Use center frequency for fixed geometry parameters.
center_frequency = 180e3  
wavelength_center = speed_of_sound / center_frequency  # Nominal wavelength based on center frequency
element_spacing = wavelength_center / 2                # Element spacing (λ/2)
element_width = wavelength_center / 2                  # Element width
num_elements = 22                                      # Number of elements
# For synchronous beams no focusing delay is applied so focal distance is unused.
# However, we still use a reflective boundary at z = 0.
# We'll only simulate for positive z (0 to 0.1 m) and generate reflections.
source_pressure = 0.8e6       # Source pressure amplitude (0.8 MPa in Pascals)

attenuation_coeff = 0.5       # Attenuation coefficient in dB/cm/MHz
attenuation_exponent = 1.0    # Frequency exponent for attenuation
spreading_model = "spherical" # Use spherical spreading (1/r decay)

# Define spatial grid: lateral x from -0.05 to 0.05 m and axial z from 0 to 0.1 m.
x_range = np.linspace(-0.05, 0.05, 1500)  # Lateral range (meters)
z_range = np.linspace(0, 0.1, 1500)         # Axial range (meters)
x, z = np.meshgrid(x_range, z_range)

# Determine transducer element positions along x-axis.
element_positions = np.linspace(
    -(num_elements - 1) * element_spacing / 2,
    (num_elements - 1) * element_spacing / 2,
    num_elements
)
# Reshape element positions for broadcasting.
element_positions_3d = element_positions.reshape(num_elements, 1, 1)

# Expand spatial grid arrays to 3D for element-wise operations.
x3 = x[np.newaxis, :, :]   # Shape: (1, M, N)
z3 = z[np.newaxis, :, :]   # Shape: (1, M, N)

# Compute distances and angles for beamforming.
delta_x = x3 - element_positions_3d                     # (num_elements, M, N)
distance_to_point = np.sqrt(delta_x**2 + z3**2)           # (num_elements, M, N)
theta = np.arctan2(delta_x, z3)                           # (num_elements, M, N)

# Apodization: Hanning window to reduce sidelobe effects.
weights = np.hanning(num_elements)
weights_3d = weights.reshape(num_elements, 1, 1)

# Prepare containers for incident and reflected field results over frequency sweep.
incident_fields = []
reflected_fields = []

# Loop over frequencies in the sweep.
for f in freqs:
    # Compute frequency-dependent parameters.
    wavelength_current = speed_of_sound / f
    phase_const_current = 2 * np.pi * f / speed_of_sound
    freq_MHz_current = f / 1e6

    # Compute element directivity using current wavelength.
    directivity = element_directivity(theta, element_width, wavelength_current)
    # Compute tissue attenuation using current frequency.
    attenuation = calculate_attenuation(distance_to_point, freq_MHz_current)
    
    # For synchronous beamforming, all elements are excited in phase:
    # Use a synchronous phase term: cos(phase_const_current * distance_to_point)
    phase_term = np.cos(phase_const_current * distance_to_point)
    
    # Geometric spreading computed as spherical spreading (1/r).
    geom_spreading = np.maximum(distance_to_point, 1e-6)
    
    # Sum the contributions over the array elements (delay-and-sum).
    summed_field = np.sum(weights_3d * directivity * phase_term * attenuation / geom_spreading, axis=0)
    
    # Normalize the incident field and scale to source pressure.
    incident_field = (summed_field / np.max(np.abs(summed_field))) * source_pressure
    
    # For synchronous simulation, the incident field is real-valued.
    incident_field = np.real(incident_field)
    
    # Simulate the reflected field by flipping the incident field across the z-axis.
    # Apply a 180° phase inversion for a hard reflection.
    reflected_field = -np.flipud(incident_field)
    
    incident_fields.append(incident_field)
    reflected_fields.append(reflected_field)

# Convert collected fields to arrays and compute composite (averaged) fields.
incident_fields = np.array(incident_fields)
reflected_fields = np.array(reflected_fields)

composite_incident = np.mean(incident_fields, axis=0)
composite_reflected = np.mean(reflected_fields, axis=0)
composite_standing = composite_incident + composite_reflected

# Visualize the composite fields using the shared plotting function.
fig, axs = plot_panels(
    x, z,
    fields=[composite_incident, composite_reflected, composite_standing],
    titles=["Composite Incident Field (Sync.)", "Composite Reflected Field (Sync.)", "Composite Standing Field (Sync.)"],
    cb_labels=["Pressure (Pa)", "Pressure (Pa)", "Pressure (Pa)"],
    cmaps=["RdBu", "RdBu", "RdBu"],
    figsize=(30, 8)
)

# Save the composite figure to an export folder.
export_dir = "exort"
if not os.path.exists(export_dir):
    os.makedirs(export_dir)
export_filename = os.path.join(export_dir, "wavephasestandingsyncsweep.png")
fig.savefig(export_filename, dpi=300)
plt.close(fig) 