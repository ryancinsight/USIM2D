"""
Focused Standing Wave Simulation with Frequency Sweep for Composite Field Generation

This script simulates focused standing waves in the presence of a reflective boundary
using a frequency sweep (from 140 kHz to 220 kHz). For each frequency, the incident field 
is computed using delay-and-sum beamforming with a focusing delay (i.e., using
(distance_to_point - r_focal)). The reflected field is generated by flipping the incident field 
(with a 180Â° phase inversion). Finally, the fields are averaged incoherently to produce a 
composite standing wave field. This composite field shows smeared-out nodes and antinodes,
demonstrating the effect of frequency sweep averaging.
 
Reference:
    Jensen, "Field II: A program for simulating ultrasound systems", 1996.
"""

import numpy as np
import matplotlib.pyplot as plt
from beamforming_utils import element_directivity, calculate_attenuation
from viz import plot_panels
import os

# -------------------------------
# Simulation Parameters
# -------------------------------

low_freq = 140e3         # Lower frequency bound (Hz)
high_freq = 220e3        # Upper frequency bound (Hz)
num_freq = 5             # Number of frequencies in sweep
freqs = np.linspace(low_freq, high_freq, num_freq)

speed_of_sound = 1480    # m/s (water)
center_frequency = 180e3 # For geometry setup
wavelength_center = speed_of_sound / center_frequency
num_elements = 22
focal_distance = 0.05    # 50 mm for focusing
source_pressure = 0.8e6  # 0.8 MPa

# (Other parameters for attenuation and spreading are maintained inside the utility functions.)
spreading_model = "spherical" # Use spherical spreading (1/r decay)

# -------------------------------
# Spatial Grid and Transducer Geometry
# -------------------------------

# Define spatial grid: lateral x from -50 mm to 50 mm; axial z from 0 to 100 mm.
x_range = np.linspace(-0.05, 0.05, 1500)  # in m
z_range = np.linspace(0, 0.1, 1500)         # in m
x, z = np.meshgrid(x_range, z_range)

# Define transducer element positions along x.
element_spacing = wavelength_center / 2
element_width = wavelength_center / 2
element_positions = np.linspace(
    -(num_elements - 1) * element_spacing / 2,
    (num_elements - 1) * element_spacing / 2,
    num_elements
)
element_positions_3d = element_positions.reshape(num_elements, 1, 1)

# Expand spatial arrays for computation.
x3 = x[np.newaxis, :, :]  # shape: (1, M, N)
z3 = z[np.newaxis, :, :]  # shape: (1, M, N)
delta_x = x3 - element_positions_3d
distance_to_point = np.sqrt(delta_x**2 + z3**2)
# Focusing: compute distance from each element to the focal point.
r_focal = np.sqrt(element_positions_3d**2 + focal_distance**2)
theta = np.arctan2(delta_x, z3)

# Apodization using Hanning window.
weights = np.hanning(num_elements)
weights_3d = weights.reshape(num_elements, 1, 1)
# Geometric spreading factor
geom_spreading = np.maximum(distance_to_point, 1e-6)

# -------------------------------
# Add helper function for computing incident field
# -------------------------------

def compute_incident_field(f, theta, element_width, r_focal, weights_3d, distance_to_point, geom_spreading, source_pressure, speed_of_sound):
    """
    Compute the focused incident field for a given frequency f.

    Args:
        f (float): Frequency in Hz.
        theta (ndarray): Angle array for directivity computation.
        element_width (float): Width of each transducer element.
        r_focal (ndarray): Focal distances for delay correction.
        weights_3d (ndarray): Apodization weights (broadcasted).
        distance_to_point (ndarray): Distance grid from elements to each field point.
        geom_spreading (ndarray): Geometric spreading factor (1/r).
        source_pressure (float): Scaling parameter for the incident field.
        speed_of_sound (float): Speed of sound in the medium.

    Returns:
        ndarray: Real-valued incident field at frequency f.
    """
    wavelength_f = speed_of_sound / f
    phase_const_f = 2 * np.pi * f / speed_of_sound
    freq_MHz = f / 1e6
    directivity_f = element_directivity(theta, element_width, wavelength_f)
    attenuation_f = calculate_attenuation(distance_to_point, freq_MHz)
    complex_field_f = np.exp(1j * phase_const_f * (distance_to_point - r_focal))
    summed_field_f = np.sum(weights_3d * directivity_f * complex_field_f * attenuation_f / geom_spreading, axis=0)
    return np.real((summed_field_f / np.max(np.abs(summed_field_f))) * source_pressure)

# -------------------------------
# Frequency Sweep Composite Simulation
# -------------------------------

# Compute incident fields using a list comprehension and generate corresponding reflected fields.
incident_fields = [compute_incident_field(f, theta, element_width, r_focal, weights_3d, distance_to_point, geom_spreading, source_pressure, speed_of_sound) for f in freqs]
reflected_fields = [-np.flipud(field) for field in incident_fields]
composite_incident = np.mean(incident_fields, axis=0)
composite_reflected = np.mean(reflected_fields, axis=0)
composite_standing = composite_incident + composite_reflected

# -------------------------------
# Visualization
# -------------------------------

fig, axs = plot_panels(
    x, z,
    fields=[composite_standing],
    titles=["Composite Standing Wave (Focused, Frequency Sweep)"],
    cb_labels=["Pressure (Pa)"],
    cmaps=["RdBu"],
    figsize=(15, 8)
)

# Save the output figure.
export_dir = "exort"
if not os.path.exists(export_dir):
    os.makedirs(export_dir)
export_filename = os.path.join(export_dir, "wavephasestandingfoc_composite.png")
fig.savefig(export_filename, dpi=300)
plt.close(fig) 